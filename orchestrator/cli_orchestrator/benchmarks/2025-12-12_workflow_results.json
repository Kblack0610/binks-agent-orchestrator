{
  "meta": {
    "date": "2025-12-12",
    "backend": "claude",
    "timestamp": "2025-12-12T15:31:28.629312"
  },
  "summary": {
    "total_tests": 8,
    "triage_correct": 8,
    "triage_accuracy": 1.0,
    "executed": 8,
    "passed_gatekeeper": 8,
    "avg_score": 9.47
  },
  "results": [
    {
      "project_id": "simple_01",
      "project_name": "String Reverse Function",
      "task": "Write a Python function that reverses a string.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\ndef reverse_string(s: str) -> str:\n    return s[::-1]\n```",
      "execution_time": 7.482865333557129,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.3,
      "final_score": 9.51,
      "timestamp": "2025-12-12T15:25:26.679228",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_02",
      "project_name": "Fizzbuzz",
      "task": "Write a fizzbuzz function in Python that prints numbers 1-100, but prints 'Fizz' for multiples of 3, 'Buzz' for multiples of 5, and 'FizzBuzz' for multiples of both.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\ndef fizzbuzz():\n    for n in range(1, 101):\n        if n % 15 == 0:\n            print('FizzBuzz')\n        elif n % 3 == 0:\n            print('Fizz')\n        elif n % 5 == 0:\n            print('Buzz')\n        else:\n            print(n)\n```",
      "execution_time": 7.671913385391235,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.7,
      "final_score": 9.79,
      "timestamp": "2025-12-12T15:25:54.255266",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_03",
      "project_name": "List Classifier",
      "task": "Write a Python function that classifies numbers into 'positive', 'negative', or 'zero'.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\ndef classify_number(n):\n    if n > 0:\n        return 'positive'\n    elif n < 0:\n        return 'negative'\n    return 'zero'\n```",
      "execution_time": 7.366361618041992,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.3,
      "final_score": 9.51,
      "timestamp": "2025-12-12T15:26:21.763554",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_04",
      "project_name": "Palindrome Checker",
      "task": "Write a Python function that checks if a string is a palindrome (reads the same forwards and backwards).",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\ndef is_palindrome(s: str) -> bool:\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]\n```",
      "execution_time": 11.835971117019653,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.3,
      "final_score": 9.51,
      "timestamp": "2025-12-12T15:26:47.808912",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_05",
      "project_name": "Binary Search",
      "task": "Write a Python function that performs binary search on a sorted list and returns the index of the target, or -1 if not found.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\ndef binary_search(sorted_list: list, target) -> int:\n    left, right = 0, len(sorted_list) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n```",
      "execution_time": 41.24644112586975,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.3,
      "final_score": 9.51,
      "timestamp": "2025-12-12T15:27:54.168314",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_06",
      "project_name": "Merge Two Sorted Lists",
      "task": "Write a Python function that merges two sorted lists into one sorted list.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\ndef merge_sorted_lists(list1: list, list2: list) -> list:\n    result = []\n    i = j = 0\n    \n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    \n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    \n    return result\n```",
      "execution_time": 11.347310066223145,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.3,
      "final_score": 9.51,
      "timestamp": "2025-12-12T15:29:11.666163",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_07",
      "project_name": "Validate Email",
      "task": "Write a Python function that validates if a string is a valid email address using regex.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\nimport re\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Validate if a string is a valid email address.\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n```",
      "execution_time": 10.342624425888062,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 8.7,
      "final_score": 9.09,
      "timestamp": "2025-12-12T15:29:51.988594",
      "backend": "claude",
      "error": null
    },
    {
      "project_id": "simple_08",
      "project_name": "Rate Limiter",
      "task": "Write a Python class that implements a simple rate limiter allowing max N requests per minute.",
      "triage_workflow": "simple",
      "expected_workflow": "simple",
      "triage_correct": true,
      "triage_reasoning": "Extracted from text response",
      "executed": true,
      "response": "```python\nimport time\nfrom collections import deque\nfrom threading import Lock\n\n\nclass RateLimiter:\n    \"\"\"Rate limiter allowing max N requests per minute using sliding window.\"\"\"\n    \n    def __init__(self, max_requests: int, window_seconds: int = 60):\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests = deque()\n        self._lock = Lock()\n    \n    def allow(self) -> bool:\n        \"\"\"Check if request is allowed and record it if so.\"\"\"\n        with self._lock:\n            now = time.monotonic()\n            cutoff = now - self.window_seconds\n            \n            # Remove expired timestamps\n            while self.requests and self.requests[0] < cutoff:\n                self.requests.popleft()\n            \n            if len(self.requests) < self.max_requests:\n                self.requests.append(now)\n                return True\n            return False\n    \n    def wait_time(self) -> float:\n        \"\"\"Return seconds to wait before next request is allowed, or 0 if allowed now.\"\"\"\n        with self._lock:\n            now = time.monotonic()\n            cutoff = now - self.window_seconds\n            \n            while self.requests and self.requests[0] < cutoff:\n                self.requests.popleft()\n            \n            if len(self.requests) < self.max_requests:\n                return 0.0\n            \n            return self.requests[0] - cutoff\n    \n    def acquire(self, timeout: float | None = None) -> bool:\n        \"\"\"Block until request is allowed or timeout expires.\"\"\"\n        start = time.monotonic()\n        while True:\n            if self.allow():\n                return True\n            \n            wait = self.wait_time()\n            if timeout is not None:\n                elapsed = time.monotonic() - start\n                if elapsed + wait > timeout:\n                    return False\n            \n            time.sleep(min(wait, 0.1))\n```",
      "execution_time": 13.470245122909546,
      "gatekeeper_score": 1.0,
      "gatekeeper_passed": true,
      "judge_score": 9.0,
      "final_score": 9.3,
      "timestamp": "2025-12-12T15:30:31.589791",
      "backend": "claude",
      "error": null
    }
  ]
}